#!/bin/python

import json
import os
import subprocess

import bibtexparser
import requests
import cloudscraper


def get_identifier() -> str:
    try:
        # return subprocess.check_output(["dmenu", "-p", "Identifier: "], stdin=subprocess.DEVNULL).decode("utf-8", "ignore")
        return input("Identifier: ")
    except (subprocess.CalledProcessError, KeyboardInterrupt):
        return ""


def get_matches(identifier: str) -> list[dict]:
    try:
        response = requests.post("http://localhost:1969/search", data=identifier, headers={"Content-Type": "text/plain"}).text
        matches = json.loads(response)

        return matches
    except (subprocess.CalledProcessError, json.JSONDecodeError):
        return []


def info_to_option(info: dict) -> str:
    return info["title"]


def select_result(matches: list[dict]) -> dict:
    try:
        options = {info_to_option(info): info for info in matches}

        options_process = subprocess.Popen(["echo", "-e", "\n".join(options.keys())], stdout=subprocess.PIPE)
        selection_process = subprocess.Popen(["dmenu", "-i", "-l", "10"], stdin=options_process.stdout, stdout=subprocess.PIPE)

        selected = selection_process.communicate()[0].decode("utf-8", "ignore").replace("\n", "")

        return options[selected]
    except subprocess.CalledProcessError:
        return {}


def parse_bibtex_file(bib_file):
    return bibtexparser.bparser.BibTexParser(common_strings=True).parse_file(bib_file)


def parse_bibtex_str(bib_str):
    return bibtexparser.bparser.BibTexParser(common_strings=True).parse(bib_str)


def info_to_bib_entry(info: dict) -> dict:
    entry_str = requests.post(
        "http://localhost:1969/export?format=bibtex", data=json.dumps([info]), headers={"Content-Type": "application/json"}
    ).text

    entry = parse_bibtex_str(entry_str).entries[0]

    return entry


def try_download_pdf(pdf_path: str, entry: dict) -> int:
    try:
        if os.path.exists(pdf_path):
            return 0

        request_web = requests.post(
            "http://localhost:1969/web", data=entry["url"], headers={"Content-Type": "text/plain"}
        )

        json_web = json.loads(request_web.text)

        url = ""
        for item in json_web:
            if item.get("itemType", "") == "attachment" and item.get("mimeType", "") == "application/pdf":
                url = item.get("url", "")

        print(url)

        with requests.get(url, stream=True) as r:
            r.raise_for_status()
            with open(pdf_path, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
    except (AttributeError) as ex:
        print(ex)
        return -1
    return 1


def get_bib_path():
    current_directory = os.getcwd()

    while current_directory != "/":
        for filename in os.listdir(current_directory):
            if filename.endswith(".bib"):
                return f"{current_directory}/{filename}"
        current_directory = os.path.dirname(current_directory)

    return None


def update_library(info: dict):
    bib_path = get_bib_path()

    if bib_path is None:
        current_directory = os.getcwd()

        bib_path = f"{current_directory}/library.bib"
        open("library.bib", "w").close()

    with open(bib_path, "r") as bib_file:
        bib_database = parse_bibtex_file(bib_file)

    new_entry = info_to_bib_entry(info)

    is_new = True
    for entry in bib_database.entries:
        if entry["ID"] == new_entry["ID"]:
            is_new = False

    if is_new:
        papers_directory = os.environ.get("PAPERS_DIRECTORY", "")
        pdf_path = f"{papers_directory}/{new_entry['ID']}.pdf"

        download_status = try_download_pdf(pdf_path, info)

        if download_status == 0:
            os.system('notify-send "PDF already available"')
        elif download_status == 1:
            os.system(f'notify-send "Downloaded pdf" "Saved paper to {pdf_path}"')
        elif download_status == -1:
            os.system('notify-send "Couldn\'t download pdf"')

        bib_database.entries.append(new_entry)

    with open(bib_path, "w") as bib_file:
        writer = bibtexparser.bwriter.BibTexWriter()
        writer.indent = "\t"
        bibtexparser.dump(bib_database, bib_file, writer)


def main():
    identifier = get_identifier()
    if not identifier:
        return

    matches = get_matches(identifier)
    if not matches:
        os.system(f'notify-send "No matches found for identifier {identifier}"')
        return

    info = select_result(matches)
    if not info:
        return

    update_library(info)


if __name__ == "__main__":
    main()
